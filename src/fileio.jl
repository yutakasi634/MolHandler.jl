import Dates

"""
    read_dcd(filename::String)::Trajectory

Return Trajectory object which filled `coordinates`, `nframe`, `natom` fields.
"""
function read_dcd(filename::String; frame_indices::Union{Vector, OrdinalRange, Colon} = :)::Trajectory

    coordinates_time_series = Matrix{Coordinate{Float32}}(undef, 0, 0)
    target_frame_indices = frame_indices

    open(filename, "r") do io
        seekend(io)
        file_size = position(io) # get file size
        seekstart(io)

        # read header first block
        skip(io, 4) # skip block size part
        header_sig = Array{Char, 1}(undef, 4)
        for i in 1:4
            header_sig[i] = read(io, Char)
        end
        total_frame_in_header = read(io, Int32)
        first_step = read(io, Int32)
        nstep_save = read(io, Int32)
        total_step     = read(io, Int32)
        total_unit     = read(io, Int32)
        header_null_4 = Array{Int32, 1}(undef, 4)
        read!(io, header_null_4)
        time_step  = read(io, Float32)
        header_null_9 = Array{Int32, 1}(undef, 9)
        read!(io, header_null_9)
        version   = read(io, Int32)
        skip(io, 4) # skip block size part

        # read header second block
        skip(io, 4)
        number_of_lines    = read(io, Int32)
        title = []
        for i in 1:number_of_lines
            line = Array{Char, 1}(undef, 80)
            for i in 1:80
                line[i] = read(io, Char)
            end
            push!(title, String(line))
        end
        skip(io, 4) # skip block size part

        # read header third block
        skip(io, 4) # skip block size part
        number_of_atom     = read(io, Int32)
        skip(io, 4) # skip block size part

        # read body block
        header_size = position(io)
        coordblocksize = (8 + 4 * number_of_atom) * 3
        total_frame = Int32((file_size - header_size) / coordblocksize)
        if typeof(target_frame_indices) == Colon
            target_frame_indices = 1:total_frame
        end

        coordinates_time_series =
            Matrix{Coordinate{Float32}}(undef, number_of_atom, length(target_frame_indices))
        output_frame_idx = 1
        for frame_idx in 1:total_frame
            # read x coordinates
            skip(io, 4) # skip block size part
            x_coords = Array{Float32, 1}(undef, number_of_atom)
            read!(io, x_coords)
            skip(io, 4) # skip block size part

            # read y coorinates
            skip(io, 4) # skip block size part
            y_coords = Array{Float32, 1}(undef, number_of_atom)
            read!(io, y_coords)
            skip(io, 4) # skip block size part

            # read z coordinates
            skip(io, 4) # skip block size part
            z_coords = Array{Float32, 1}(undef ,number_of_atom)
            read!(io, z_coords)
            skip(io, 4) # skip block size part

            if frame_idx âˆˆ target_frame_indices
                atoms = collect(eachrow(hcat(x_coords, y_coords, z_coords)))
                coordinates_time_series[:, output_frame_idx] = Coordinate.(atoms)
                output_frame_idx += 1
            end
        end
    end
    Trajectory(coordinates_time_series)
end

"""
    write_dcd(filename::String, trj::Trajectory;
              save_step::Integer = 1, total_step::Integer = trj.nframe,
              unit_num::Integer  = 1,  time_step::Real = 1.0f0)

Write `coordinates`, `nframe` and `natom` infomation of `trj` to dcd file, named `filename`.
dcd file contain other information - save interval step, unit(chain) number in the system, total step and time step of original trajectory -, and if you do not specify these parameter, these are filled with default value.
"""
function write_dcd(filename::String, trj::Trajectory;
                   save_step::Integer = 1, total_step::Integer = trj.nframe,
                   unit_num::Integer = 1, time_step::Real = 1.0f0)
    open(filename, "w") do io

        # write header first block
        write(io, Int32(84))         # block size
        write(io, "CORD")            # signature
        write(io, Int32(trj.nframe)) # number of frames
        write(io, Int32(0))          # first frame index
        write(io, Int32(save_step))  # nstep_save
        write(io, Int32(total_step)) # number of steps
        write(io, Int32(unit_num))   # number of units
        write(io, zeros(Int32, 4))
        write(io, time_step)         # time step
        write(io, zeros(Int32, 9))
        write(io, Int32(24))         # version
        write(io, Int32(84))         # block size

        # write header second block
        write(io, Int32(84))         # block size
        write(io, Int32(1))          # number of lines
        write(io, "Generated by MolHandler.jl ((c) Yutaka Murata 2020) at $(Dates.format(Dates.now(), "yyyy-mm-dd HH:MM:SS"))      ")
        write(io, Int32(84))

        # write header third block
        write(io, Int32(4))
        write(io, Int32(trj.natom))
        write(io, Int32(4))

        # write body block
        coord_part_size = 4 * trj.natom
        each_block_size = 8 + coord_part_size
        for frame_idx in 1:trj.nframe
            # write x coordinates
            write(io, Int32(coord_part_size))
            for atom_idx in 1:trj.natom
                write(io, Float32(trj.coordinates[atom_idx, frame_idx].x))
            end
            write(io, Int32(coord_part_size))

            # write y coordinates
            write(io, Int32(coord_part_size))
            for atom_idx in 1:trj.natom
                write(io, Float32(trj.coordinates[atom_idx, frame_idx].y))
            end
            write(io, Int32(coord_part_size))

            # write z coordinates
            write(io, Int32(coord_part_size))
            for atom_idx in 1:trj.natom
                write(io, Float32(trj.coordinates[atom_idx, frame_idx].z))
            end
            write(io, Int32(coord_part_size))
        end
    end
end

"""
    read_pdb(filename::String; model = :unspecified)::Trajectory

Return Trajectory object which filled all field.
If you set `:AA` to model field, this function set the mass of particle based on atomname field.
If you set `:CA` to model field, this function set the mass of particcle mase on resname field.
"""
function read_pdb(filename::String; model = :unspecified)::Trajectory
    lines = open(filename, "r") do io
        readlines(io)
    end

    attributes = Vector{Attribute}()
    coordinates = Vector{Coordinate{Float32}}()
    for line in lines
        if occursin(r"^(ATOM|HETATM)", line)
            atomid   = parse(Int64, line[7:11])
            atomname = strip(line[13:16])
            resname  = strip(line[18:20])
            resid    = parse(Int64, line[23:26])
            x_coord  = parse(Float32, line[31:38])
            y_coord  = parse(Float32, line[39:46])
            z_coord  = parse(Float32, line[47:54])

            if model == :unspecified
                push!(attributes, Attribute(resname = resname, resid = resid,
                                            atomname = atomname, atomid = atomid))
            elseif model == :AA
                push!(attributes, Attribute(resname = resname, resid = resid,
                                            atomname = atomname, atomid = atomid,
                                            mass = atom_mass(atomname)))
            elseif model == :CA
                push!(attributes, Attribute(resname = resname, resid = resid,
                                           atomname = atomname, atomid = atomid,
                                           mass = residue_mass(resname)))
            end
            push!(coordinates, Coordinate([x_coord, y_coord, z_coord]))
        end
    end
    Trajectory(reshape(coordinates, (length(coordinates), 1) ), attributes)
end
